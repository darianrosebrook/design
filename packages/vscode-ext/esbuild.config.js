/**
 * @fileoverview ESBuild configuration for VS Code extension
 * @author @darianrosebrook
 *
 * Bundles the extension and webview code with proper externals for VS Code.
 */

import * as esbuild from "esbuild";
import { createHash } from "crypto";
import { writeFileSync, readFileSync } from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const isProduction = process.env.NODE_ENV === "production";
const isWatch = process.argv.includes("--watch");
const buildWebviewOnly = process.argv.includes("--webview-only");

/**
 * Build configuration for the main extension bundle
 */
const extensionConfig = {
  entryPoints: ["./src/index.ts"],
  bundle: true,
  outfile: "./dist/index.js",
  platform: "node",
  target: "node18",
  format: "cjs",
  sourcemap: !isProduction,
  minify: false, // Keep readable for debugging
  external: ["vscode"], // VSCode provides this at runtime
  banner: {
    js: "// @ts-check\n// Auto-generated by esbuild - do not edit manually",
  },
  logLevel: "info",
};

/**
 * Build configuration for React bundle (shared across webviews)
 */
const reactBundleConfig = {
  entryPoints: ["./webviews/canvas/react-bundle.ts"],
  bundle: true,
  outfile: "./dist/webviews/react.js",
  platform: "browser",
  target: "es2020",
  format: "iife",
  sourcemap: !isProduction,
  minify: isProduction,
  define: {
    "process.env.NODE_ENV": JSON.stringify(
      process.env.NODE_ENV || "development"
    ),
  },
  globalName: "ReactBundle",
  logLevel: "info",
};

/**
 * Build configuration for the canvas webview bundle
 */
const canvasWebviewConfig = {
  entryPoints: ["./webviews/canvas/index.tsx"],
  bundle: true,
  outfile: "./dist/webviews/canvas.js",
  platform: "browser",
  target: "es2020",
  format: "iife",
  sourcemap: !isProduction,
  minify: isProduction,
  define: {
    "process.env.NODE_ENV": JSON.stringify(
      process.env.NODE_ENV || "development"
    ),
  },
  external: ["react", "react-dom"], // Externalize React to prevent multiple instances
  loader: {
    ".css": "text",
    ".svg": "text",
  },
  logLevel: "info",
};

/**
 * Generate deterministic hash for bundle integrity
 */
function generateBundleHash(filepath) {
  const content = readFileSync(filepath);
  const hash = createHash("sha256").update(content).digest("hex");
  console.info(`âœ… Generated bundle hash: ${hash.substring(0, 16)}...`);

  // Write hash to manifest file
  const manifestPath = path.join(__dirname, "dist/webviews/manifest.json");
  const manifest = {
    canvas: {
      file: "canvas.js",
      hash,
      // Use build hash for deterministic builds (no timestamp)
      buildHash: process.env.BUILD_HASH || "unknown",
      generatedAt: new Date().toISOString(), // For debugging only, not used in hash
    },
  };
  writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));

  return hash;
}

/**
 * Build the main extension bundle
 */
async function buildExtension() {
  try {
    console.info("ðŸš€ Building extension bundle...");

    // First generate TypeScript declarations
    console.info("ðŸ“ Generating TypeScript declarations...");
    const { execSync } = await import("child_process");
    execSync("tsc --emitDeclarationOnly --outDir dist", { stdio: "inherit" });

    // Then bundle with esbuild
    const result = await esbuild.build(extensionConfig);

    console.info("âœ… Extension bundle built successfully");

    return result;
  } catch (error) {
    console.error("âŒ Extension build failed:", error);
    throw error;
  }
}

/**
 * Build the React bundle
 */
async function buildReactBundle() {
  try {
    console.info("ðŸš€ Building React bundle...");

    const result = await esbuild.build(reactBundleConfig);

    console.info("âœ… React bundle built successfully");

    return result;
  } catch (error) {
    console.error("âŒ React bundle build failed:", error);
    throw error;
  }
}

/**
 * Build the canvas webview
 */
async function buildCanvasWebview() {
  try {
    console.info("ðŸš€ Building canvas webview bundle...");

    const result = await esbuild.build(canvasWebviewConfig);

    // Generate hash for production builds
    if (isProduction && !isWatch) {
      const bundlePath = path.join(__dirname, "dist/webviews/canvas.js");
      generateBundleHash(bundlePath);
    }

    console.info("âœ… Canvas webview bundle built successfully");

    return result;
  } catch (error) {
    console.error("âŒ Canvas webview build failed:", error);
    throw error;
  }
}

/**
 * Watch mode for development
 */
async function watchMode() {
  console.info("ðŸ‘€ Starting watch mode...");

  const contexts = [];

  // Watch extension code
  if (!buildWebviewOnly) {
    const extensionContext = await esbuild.context({
      ...extensionConfig,
      plugins: [
        {
          name: "extension-rebuild-notify",
          setup(build) {
            build.onEnd((result) => {
              if (result.errors.length === 0) {
                console.info("âœ… Extension rebuilt");
              } else {
                console.error("âŒ Extension rebuild failed");
              }
            });
          },
        },
      ],
    });
    contexts.push(extensionContext);
  }

  // Watch React bundle
  const reactContext = await esbuild.context({
    ...reactBundleConfig,
    plugins: [
      {
        name: "react-rebuild-notify",
        setup(build) {
          build.onEnd((result) => {
            if (result.errors.length === 0) {
              console.info("âœ… React bundle rebuilt");
            } else {
              console.error("âŒ React bundle rebuild failed");
            }
          });
        },
      },
    ],
  });
  contexts.push(reactContext);

  // Watch webview code
  const webviewContext = await esbuild.context({
    ...canvasWebviewConfig,
    plugins: [
      {
        name: "webview-rebuild-notify",
        setup(build) {
          build.onEnd((result) => {
            if (result.errors.length === 0) {
              console.info("âœ… Canvas webview rebuilt");
            } else {
              console.error("âŒ Canvas webview rebuild failed");
            }
          });
        },
      },
    ],
  });
  contexts.push(webviewContext);

  // Start watching all contexts
  await Promise.all(contexts.map((ctx) => ctx.watch()));
  console.info("ðŸ‘€ Watching for changes...");
}

// Main execution
if (isWatch) {
  watchMode().catch((error) => {
    console.error("Watch mode error:", error);
    process.exit(1);
  });
} else {
  (async () => {
    try {
      // Build extension first (unless webview-only mode)
      if (!buildWebviewOnly) {
        await buildExtension();
      }

      // Build React bundle and webview
      await buildReactBundle();
      await buildCanvasWebview();

      console.info("ðŸŽ‰ All builds completed successfully!");
    } catch (error) {
      console.error("Build error:", error);
      process.exit(1);
    }
  })();
}
